import{j as e,b as i,c as s,aa as a}from"./chunks/framework._Kr-eMMD.js";const F=JSON.parse('{"title":"Client-go系列一：Client-go知识体系","description":"","frontmatter":{"sidebar":false,"date":"2022-10-02T00:00:00.000Z","tag":["Go","Client-go"],"sticky":1,"next":{"text":"Client-go系列二: 认识ClientSet","link":"/posts/programming/go/client-go/clientset"},"head":[]},"headers":[],"relativePath":"posts/programming/go/client-go/intro.md","filePath":"posts/programming/go/client-go/intro.md","lastUpdated":1714451013000}'),t={name:"posts/programming/go/client-go/intro.md"},n=a(`<h1 id="client-go系列一-client-go知识体系" tabindex="-1">Client-go系列一：Client-go知识体系 <a class="header-anchor" href="#client-go系列一-client-go知识体系" aria-label="Permalink to &quot;Client-go系列一：Client-go知识体系&quot;">​</a></h1><p>初步认识 Client-go 主体框架.</p><h2 id="关于client-go" tabindex="-1">关于client-go <a class="header-anchor" href="#关于client-go" aria-label="Permalink to &quot;关于client-go&quot;">​</a></h2><p><code>client-go</code>是kubernetes官方提供的go语言的客户端库，go应用使用该库可以访问kubernetes的API Server，这样我们就能通过编程来对kubernetes资源进行增删改查操作。</p><p>除了提供丰富的API用于操作kubernetes资源，<code>client-go</code>还为<code>controller</code>和<code>operator</code>提供了重要支持，如下图，<code>client-go</code>的<code>informer</code>机制可以将<code>controller</code>关注的资源变化及时带给此<code>controller</code>，使<code>controller</code>能够及时响应变化：</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/client-go-image.png" alt="" loading="lazy"></p><p>我们先来瞄一眼 <code>client-go</code> 的主要代码结构，我会给出各个主要部分的核心功能让大家有一个感性的认识：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tree</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -L</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> client-go</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">client-go</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> discovery</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 包含dicoveryClient，用于发现k8s所支持GVR(Group/Version,/Resource),&#39;kubectl api-resources&#39;命令正是使用它来列出cluster中的各种资源。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dynamic</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 包含dynamicClient，它封装了 RESTClient，可以动态的指定api资源的GVR，结合unstructured.Unstructured类型来访问各种类型的k8s资源(如: Pod,Deploy...)，也可以访问用户自定义资源(CRD)。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> informers</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 为了减少client对于apiserver的频繁访问，需要informer来缓存apiserver中资源，只有当api资源对象发生变化的时候才收到通知。每种api资源会有自己的informer实现，也是按照api分组与版本来区分。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> kubernetes</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 主要定义ClientSet，它也对restClient进行了封装，并且包含对各种k8s资源和版本的管理方法。每个api资源有单独的client，而ClientSet则是多个客户端的集合。ClientSet以及每种k8s内置资源的client的所有请求最终还是由restClient发出的；在typed目录包括具体每种k8s内置资源的client实现，也是按照api分组与版本来区分。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clientset.go</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> typed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> listers</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 包含各种k8s内置资源的只读客户端。每种lister都有Get()和List()方法，并且结果都是从缓存中读取的。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rest</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 包含真正给apiserver发请求的client，实现了Restful的API，同时支持Protobuf和JSON格式数据。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> scale</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 只要包含scalClient用于Deploy, RS等的扩/缩容。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tools</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 各种类型的工具包，常见的比如获取kubeconfig的方法，以SharedInformer、Reflector、DealtFIFO和Indexer等工具，这些工具主要用于实现client查询和缓存机制，减轻apiserver的负载等。</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">注意📢：</p><p>为了简化，不重要的文件与目录没有列出来。</p></div><h2 id="客户端对象" tabindex="-1">客户端对象 <a class="header-anchor" href="#客户端对象" aria-label="Permalink to &quot;客户端对象&quot;">​</a></h2><p><code>Client-go</code> 提供了以下四种客户端对象与kubernetes的API Server进行交互</p><h3 id="restclient" tabindex="-1"><code>RESTClient</code> <a class="header-anchor" href="#restclient" aria-label="Permalink to &quot;\`RESTClient\`&quot;">​</a></h3><p>这是最基础的客户端对象，仅对<code>HTTPRequest</code>进行了封装，实现RESTFul风格API，这个对象的使用并不方便，因为很多参数都要使用者来设置，于是<code>client-go</code>基于<code>RESTClient</code>又实现了三种新的客户端对象。</p><h3 id="clientset" tabindex="-1"><code>ClientSet</code> <a class="header-anchor" href="#clientset" aria-label="Permalink to &quot;\`ClientSet\`&quot;">​</a></h3><p>把<code>Resource</code>和<code>Version</code>也封装成方法了，用起来更简单直接，一个资源是一个客户端，多个资源就对应了多个客户端，所以<code>ClientSet</code>就是多个客户端的集合了，这样就好理解了，不过<code>ClientSet</code>只能访问内置资源，访问不了自定义资源。</p><h3 id="dynamicclient" tabindex="-1"><code>DynamicClient</code> <a class="header-anchor" href="#dynamicclient" aria-label="Permalink to &quot;\`DynamicClient\`&quot;">​</a></h3><p>可以访问内置资源和自定义资源，拿出的内容是<code>Object</code>类型，按实际情况自己去做强制转换，当然了也会有强转失败的风险。</p><h3 id="discoveryclient" tabindex="-1"><code>DiscoveryClient</code> <a class="header-anchor" href="#discoveryclient" aria-label="Permalink to &quot;\`DiscoveryClient\`&quot;">​</a></h3><p>用于发现kubernetes的API Server支持的<code>Group</code>、<code>Version</code>、<code>Resources</code>等信息。</p><h3 id="各模块的依赖关系" tabindex="-1">各模块的依赖关系 <a class="header-anchor" href="#各模块的依赖关系" aria-label="Permalink to &quot;各模块的依赖关系&quot;">​</a></h3><p><code>client-go</code> 主要功能模块以及各模块的依赖关系大致如下面这张图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/client-go-module.jpg" alt="" loading="lazy"></p><p>可以看到，不管是各种静态类型的客户端 <code>ClientSet</code> ，动态客户端 <code>DynamicClient</code> 还是资源发现客户端 <code>DiscoveryClient</code> 都封装了 <code>RESTClient</code>，也就是说最后请求的发送都是有 <code>RESTClient</code> 发送给 <code>kube-apiserver</code> 的。而 <code>k8s.io/api-machinery</code> 中 API 资源的分组与版本是所有类型客户端的基础，具体每种 API 资源的定义则是包含在 <code>k8s.io/api</code> 模块。</p>`,23),l=[n];function o(c,r,d,p,h,k){return i(),s("div",null,l)}const C=e(t,[["render",o]]);export{F as __pageData,C as default};
