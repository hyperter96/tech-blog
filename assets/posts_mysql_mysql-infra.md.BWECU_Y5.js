import{_ as e,c as a,o as t,a7 as s}from"./chunks/framework.B28k8k1F.js";const q=JSON.parse('{"title":"MySQL知识系列一：MySQL架构图","description":"","frontmatter":{"sidebar":false,"cover":"https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/mysql-cover.jpg","date":"2024-05-03T00:00:00.000Z","sticky":1,"tags":["kubernetes","MySQL"],"next":{"text":"MySQL知识系列二：MySQL索引","link":"/posts/mysql/mysql-index"},"head":[]},"headers":[],"relativePath":"posts/mysql/mysql-infra.md","filePath":"posts/mysql/mysql-infra.md","lastUpdated":1739612366000}'),o={name:"posts/mysql/mysql-infra.md"},d=s('<h1 id="mysql知识系列一-mysql架构图" tabindex="-1">MySQL知识系列一：MySQL架构图 <a class="header-anchor" href="#mysql知识系列一-mysql架构图" aria-label="Permalink to &quot;MySQL知识系列一：MySQL架构图&quot;">​</a></h1><p>Mysql服务端架构分为Server层和存储引擎层（可插拔式），Server层主要包含了连接器、缓存模块、分析器、优化器、执行器；可插拔的存储引擎主要有InnoDB、MyISAM、Memory。当一个请求进入后的执行流程如下图的箭头所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/mysql-infra.png" alt="" loading="lazy"></p><h2 id="server层" tabindex="-1">Server层 <a class="header-anchor" href="#server层" aria-label="Permalink to &quot;Server层&quot;">​</a></h2><h3 id="连接器" tabindex="-1">连接器 <a class="header-anchor" href="#连接器" aria-label="Permalink to &quot;连接器&quot;">​</a></h3><p>连接器主要负责与Mysql客户端建立连接，权限认证，维持和管理链接。当开始连接服务器时需要使用账号、密码登录服务器，执行命令：<code>mysql -h $ip -P $port -u $root -p $password</code></p><p>如果用户名验证不通过则会报错：<code>Access denied for user；</code>成功则继续调用权限表，获取用户权限信息，存储到类似本地线程变量中，后续分析器、优化器中会使用。当给当前用户权限进行修改后，自己需要重新登录才能获取新的权限信息，类似我们自己写权限相关代码时，会将权限、角色等相关信息存储到线程本地变量 <code>ThreadLocal</code> 中。</p><p>当与服务器建立链接后，我们可以使用 <code>show processlist；</code> 命令查看当前链接到服务器的客户端链接信息，如果<code>status</code>为<code>sleep</code>等状态表示处于空闲状态。记得自己刚开始开发项目时，客户端没有配置好，服务器请求量很低，特别是晚上，第二天来就会看到报错：<code>Lost connection to MySQL server during query</code>。就是在连接器模块报错的，服务端配置 <code>wait_timeout</code> 可以设置客户端再次请求时，判断是否超时，为8小时。</p><p>与服务器端的链接分为长链接和短连接。短连接本身每次都会执行TCP的三次握手和四次挥手，并且建立链接后会进行认证和权限相关的操作，我们需要防止客户端并发量递增时对服务器端的短连接风暴。现在开发项目Mysql客户端基本都基于线程池实现，线程本身是复用的长链接，长链接的弊端是会在服务端线程内部存储大量的查询缓存等信息，只有断开链接时才会释放。所以最好是使用长链接的同时，当执行了比较大的事务之后，手动断开链接，释放资源。在 5.7版本之后，<code>mysql</code>增加了<code>mysql_reset_connection</code>参数可以将链接初始化到刚刚创建链接时的状态，我们可以在长事务或者定时执行该操作。</p><h3 id="缓存模块" tabindex="-1">缓存模块 <a class="header-anchor" href="#缓存模块" aria-label="Permalink to &quot;缓存模块&quot;">​</a></h3><p>缓存模块是一直比较弊病的模块，在 Mysql 8之后已经废弃掉了。由于查询时根据整个sql进行hash计算，我们知道hash计算哪怕原字符有一个标点不同那么hash值也完全不同，所以一定要sql一模一样才能匹配缓存。但是整个表只要有一点修改操作就会将所有缓存进行删除，即可能费了很大的力气进行缓存，但是还没执行缓存查询就被删除了。所以缓存只适用于配置表等基本不会变动的数据，但是个人理解，随着redis等旁路缓存的普及，基于所有的项目都有缓存，那么数据库的缓存弊病多使用。</p><ul><li><code>query_cache_type</code> 设置为 <code>off/on</code> 缓存是否开启；</li><li><code>query_cache_size = 0</code>：缓存大小，可以设置如：<code>128M</code>；</li><li>也可以将 <code>query_cache_type</code> 设置为 ：<code>DEMAND</code>， 在需要缓存时显示调用，如： <code>select SQL_CAHCE * from table where id = 100;</code></li></ul><h3 id="分析器-分析需要做什么" tabindex="-1">分析器（分析需要做什么） <a class="header-anchor" href="#分析器-分析需要做什么" aria-label="Permalink to &quot;分析器（分析需要做什么）&quot;">​</a></h3><p>读执行的sql进行词法和语法分析，词法分析需要解析如<code>select</code>是一个查询语句，查询的具体表名，查询的条件等；语法分析如 sql字符串 是否符合sql规范，是否符合Mysql 自己的sql规范等。一般遇到的</p><p><code>you have an error in your SQL syntax use near...</code>就是在该模块报出的。</p><h3 id="优化器-分析怎么做" tabindex="-1">优化器（分析怎么做） <a class="header-anchor" href="#优化器-分析怎么做" aria-label="Permalink to &quot;优化器（分析怎么做）&quot;">​</a></h3><p>优化器主要负责索引的选择、多表关联时的 <code>join</code> 顺序，这些都具体在后面专门进行分析。</p><h3 id="执行器-执行过程" tabindex="-1">执行器（执行过程） <a class="header-anchor" href="#执行器-执行过程" aria-label="Permalink to &quot;执行器（执行过程）&quot;">​</a></h3><p>执行器负责具体调用底层的存储引擎接口，处理数据。<code>rows_examined</code>调用底层引擎接口查询的条数或次数， 有可能这里调用一次叠加一次，但是内部可能查询了多行数据。</p><h2 id="存储引擎层" tabindex="-1">存储引擎层 <a class="header-anchor" href="#存储引擎层" aria-label="Permalink to &quot;存储引擎层&quot;">​</a></h2><p>常用的存储引擎有<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>，现在很多公司的数据库规范直接规定创建表只能使用 <code>InnoDB</code>，不仅仅是因为支持事务，还与运维时候的数据备份等相关。在 Mysql 5.5后，将默认的存储引擎从 <code>MyISAM</code>变更为 <code>InnoDB</code>，只是个人还是比较喜欢或者建议在创建表时，显示设置存储引擎 <code>engine = Innodb</code>。<code>Memory</code>引擎作为临时表的默认存储引擎，当执行复杂sql或数据量比较大需要使用临时表；或者我们自己手动基于临时表实现业务时，都会用到Memory存储引擎，所以还是需要关注的。存储引擎需要关注具体的数据结构：</p><table tabindex="0"><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Hash索引</td><td></td><td></td><td>√</td></tr><tr><td>R-Tree索引</td><td>√</td><td></td><td></td></tr><tr><td>Full-text索引</td><td>√</td><td></td><td></td></tr></tbody></table><p>InnoDB只支持B+树的数据结构，而Memory引擎支持B+树和Hash索引。 B+树支持快速的读写，并且时间复杂度为<code>O(logN)</code>，支持区间查询。Hash索引读写的时间复杂度近似<code>O(1)</code>，比较适合内存中使用，不支持区间查询。</p><h2 id="查询流程" tabindex="-1">查询流程 <a class="header-anchor" href="#查询流程" aria-label="Permalink to &quot;查询流程&quot;">​</a></h2><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> email </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;XXX&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 比如该表使用 innoDB引擎</span></span></code></pre></div><ol><li>【连接器】先使用长链接或者短链接，使用用户名和密码进行登录操作；</li><li>【连接器】执行上面的<code>select</code>语句，到连接器；</li><li>【缓存模块】判断是否有开启缓存，或者要查询缓存，有查询完成后需要回执缓存；</li><li>【解析器】检查sql的词法、语法分析，是否sql有问题；</li><li>【优化器】判断是否有索引，是否需要进行优化等（这里没有<code>join</code>等操作）；</li></ol><p><code>email</code>无索引：</p><ol start="6"><li>【执行器】、调用innoDB引擎接口获取表的第一条数据，判断 <code>email</code>是否相等，如果是则放入结果集中，叠加器<code>rows_examined++</code></li><li>【执行器】、重复执行上面的动作，一直到表的最后一行</li><li>【执行器】、将结果集返回给客户端</li></ol><p><code>email</code>有索引：（之前一直以为是innoDB直接返回了所有满足条件的结果集给执行器）</p><ol start="6"><li>【执行器】、调用InnoDB的满足条件的第一行数据，内部查询走索引</li><li>【执行器】、获取满足条件的下一行</li><li>【执行器】、返回结果集</li></ol>',30),i=[d];function l(r,c,n,h,p,y){return t(),a("div",{"data-pagefind-body":!0},i)}const k=e(o,[["render",l]]);export{q as __pageData,k as default};
