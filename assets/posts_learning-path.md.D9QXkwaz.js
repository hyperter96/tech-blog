import{j as e,b as o,c as a,aa as c}from"./chunks/framework._Kr-eMMD.js";const m=JSON.parse('{"title":"关于研究技术的思维和规划","description":"","frontmatter":{"sidebar":false,"date":"2021-03-05T00:00:00.000Z","cover":"https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/background7.jpeg","tags":["其它"],"head":[]},"headers":[],"relativePath":"posts/learning-path.md","filePath":"posts/learning-path.md","lastUpdated":1716878244000}'),i={name:"posts/learning-path.md"},t=c('<h1 id="关于研究技术的思维和规划" tabindex="-1">关于研究技术的思维和规划 <a class="header-anchor" href="#关于研究技术的思维和规划" aria-label="Permalink to &quot;关于研究技术的思维和规划&quot;">​</a></h1><h2 id="研究技术的思维" tabindex="-1">研究技术的思维 <a class="header-anchor" href="#研究技术的思维" aria-label="Permalink to &quot;研究技术的思维&quot;">​</a></h2><h3 id="研究每项技术的意义" tabindex="-1">研究每项技术的意义 <a class="header-anchor" href="#研究每项技术的意义" aria-label="Permalink to &quot;研究每项技术的意义&quot;">​</a></h3><p>当我每次研究一项新的技术的时候，我都会思考这项技术的意义：</p><ul><li>这项技术的发展背景</li><li>为什么要发展这项技术？有什么好处？</li><li>这项技术解决了什么问题？</li></ul><p>当学完以后，可以用一句话概括/总结这项技术。这是研究技术思维最精辟的方法。举个例子：</p><div class="important custom-block github-alert"><p class="custom-block-title">Cilium的发展背景</p><p></p><p>随着云原生的普及率越来越高，各大厂商基本上或多或少都实现了业务的 K8s 容器化，头部云计算厂商更是不用说。 而且随着 K8s 的 普及，当前集群逐渐呈现出以下两个特点：</p><ul><li>容器数量越来越多，比如：K8s 官方单集群就已经支持 150k pod</li><li>Pod 生命周期越来越短，Serverless 场景下甚至短至几分钟，几秒钟</li></ul><p>随着容器密度的增大，以及生命周期的变短，对原生容器网络带来的挑战也越来越大。当前 K8s Service 负载均衡 的实现现状，在 Cilium 出现之前， Service 由 <code>kube-proxy</code> 来实现，实现方式有 <code>userspace</code>，<code>iptables</code>，<code>ipvs</code> 三种模式。</p><p><strong>Userspace</strong></p><p>当前模式下，<code>kube-proxy</code> 作为反向代理，监听随机端口，通过 <code>iptables</code> 规则将流量重定向到代理端口，再由 <code>kube-proxy</code> 将流量转发到 后端 pod。Service 的请求会先从用户空间进入内核 <code>iptables</code>，然后再回到用户空间，代价较大，性能较差。</p><p><strong>Iptables</strong></p><p>存在的问题：</p><ul><li>可扩展性差。随着 service 数据达到数千个，其控制面和数据面的性能都会急剧下降。原因在于 <code>iptables</code> 控制面的接口设计中，每添加一条规则，需要遍历和修改所有的规则，其控制面性能是<code>O(n²)</code>。在数据面，规则是用链表组织的，其性能是<code>O(n)</code>。</li><li>LB 调度算法仅支持随机转发。</li></ul><p><strong>Ipvs 模式</strong></p><p>IPVS 是专门为 LB 设计的。它用 <code>hash table</code> 管理 service，对 service 的增删查找都是<code>O(1)</code>的时间复杂度。不过 IPVS 内核模块没有 <code>SNAT</code> 功能，因此借用了 <code>iptables</code> 的 <code>SNAT</code> 功能。 IPVS 针对报文做 <code>DNAT</code> 后，将连接信息保存在 <code>nf_conntrack</code> 中，<code>iptables</code> 据此接力做 <code>SNAT</code>。该模式是目前 Kubernetes 网络性能最好的选择。但是由于 <code>nf_conntrack</code> 的复杂性，带来了很大的性能损耗。</p></div><blockquote><p>所以为什么要发展Cilium？</p></blockquote><p>核心原因是Cilium 位于容器编排系统和 Linux Kernel 之间，向上可以通过编排平台为容器进行网络以及相应的安全配置，向下可以通过在 Linux 内核挂载 eBPF 程序，来控制容器网络的转发行为以及安全策略执行。</p><blockquote><p>Cilium解决了什么问题？</p></blockquote><p>Cilium 是基于 eBpf 的一种开源网络实现，通过在 Linux 内核动态插入强大的安全性、可见性和网络控制逻辑，提供网络互通，服务负载均衡，安全和可观测性等解决方案。简单来说可以理解为 <code>Kube-proxy + CNI</code> 网络实现。</p><blockquote><p>一句话总结概括Cilium</p></blockquote><p>Cilium 是基于 eBpf 的一种开源网络方案，原理是通过Linux 内核动态编程式交互，提供网络互通，服务负载均衡，安全和可观测性等解决方案。</p><h3 id="灵魂拷问掌握程度" tabindex="-1">灵魂拷问掌握程度 <a class="header-anchor" href="#灵魂拷问掌握程度" aria-label="Permalink to &quot;灵魂拷问掌握程度&quot;">​</a></h3><p>随着时间的推移，我们可能会忘记新学的知识，需要加强记忆才会印象深刻。从而，我们才能烂记于心。</p><div class="important custom-block github-alert"><p class="custom-block-title">怎样才能衡量掌握程度呢？</p><p></p><p>最好可以问问自己：</p><ul><li>在脑海中是否可以清晰的描绘出技术架构？</li><li>是否可以一句话概括技术？</li><li>这项技术在实际生活中有哪些解决方案的实践？</li></ul></div><h2 id="看源代码的思路" tabindex="-1">看源代码的思路 <a class="header-anchor" href="#看源代码的思路" aria-label="Permalink to &quot;看源代码的思路&quot;">​</a></h2><p>建议由浅入深，深入浅出。</p><ul><li>由浅入深：找到入口文件的<code>main</code>函数，一步步深入代码的细节</li><li>深入浅出：了解完代码的细节，脑中应该逐渐呈现代码的流程走向图</li></ul>',19),l=[t];function d(s,p,r,n,u,h){return o(),a("div",null,l)}const _=e(i,[["render",d]]);export{m as __pageData,_ as default};
