import{j as s,c as i,b as a,aa as e}from"./chunks/framework.Cst8pIsI.js";const g=JSON.parse('{"title":"Go 基础知识系列七：延迟函数调用Defer","description":"","frontmatter":{"sidebar":false,"cover":"https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/go-cover1-slices.jpeg","date":"2022-07-13T00:00:00.000Z","tag":["Go","编程基础"],"sticky":1,"prev":{"text":"Go 基础知识系列六：互斥锁mutex","link":"/posts/programming/go/mutex"},"head":[]},"headers":[],"relativePath":"posts/programming/go/defer.md","filePath":"posts/programming/go/defer.md","lastUpdated":1738671020000}'),n={name:"posts/programming/go/defer.md"},p=e(`<h1 id="go-基础知识系列七-延迟函数调用defer" tabindex="-1">Go 基础知识系列七：延迟函数调用Defer <a class="header-anchor" href="#go-基础知识系列七-延迟函数调用defer" aria-label="Permalink to &quot;Go 基础知识系列七：延迟函数调用Defer&quot;">​</a></h1><p><code>defer</code>语句用于延迟函数的调用，每次<code>defer</code>都会把一个函数压入栈中，函数返回前再把延迟的函数取出并执行。</p><p>为了方便描述，我们把创建<code>defer</code>的函数称为主函数，<code>defer</code>语句后面的函数称为延迟函数。</p><p>延迟函数可能有输入参数，这些参数可能来源于定义<code>defer</code>的函数，延迟函数也可能引用主函数用于返回的变量，也就是说延迟函数可能会影响主函数的一些行为，这些场景下，如果不了解<code>defer</code>的规则很容易出错。</p><h2 id="规则一-延迟函数的参数在defer语句出现时就已经确定" tabindex="-1">规则一：延迟函数的参数在defer语句出现时就已经确定 <a class="header-anchor" href="#规则一-延迟函数的参数在defer语句出现时就已经确定" aria-label="Permalink to &quot;规则一：延迟函数的参数在defer语句出现时就已经确定&quot;">​</a></h2><p>官方给出一个例子，如下所示：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>defer</code>语句中的<code>fmt.Println()</code>参数i值在<code>defer</code>出现时就已经确定下来，实际上是拷贝了一份。后面对变量<code>i</code>的修改不会影响<code>fmt.Println()</code>函数的执行，仍然打印<code>0</code>。</p><div class="warning custom-block"><p class="custom-block-title">注意📢：</p><p>对于指针类型参数，规则仍然适用，只不过延迟函数的参数是一个地址值，这种情况下，<code>defer</code>后面的语句对变量的修改可能会影响延迟函数。</p></div><div class="important custom-block github-alert"><p class="custom-block-title">例子一</p><p></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deferFuncParameter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> aInt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(aInt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  aInt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>题目说明：函数<code>deferFuncParameter()</code>定义一个整型变量并初始化为<code>1</code>，然后使用<code>defer</code>语句打印出变量值，最后修改变量值为<code>2</code>.</p><p>参考答案：输出<code>1</code>。延迟函数<code>fmt.Println(aInt)</code>的参数在<code>defer</code>语句出现时就已经确定了，所以无论后面如何修改<code>aInt</code>变量都不会影响延迟函数。</p></div><p>我们再来看另一个例子：</p><div class="important custom-block github-alert"><p class="custom-block-title">例子二</p><p></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fmt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array[i])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deferFuncParameter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> aArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  defer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">aArray)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  aArray[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  deferFuncParameter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>函数说明：函数<code>deferFuncParameter()</code>定义一个数组，通过<code>defer</code>延迟函数<code>printArray()</code>的调用，最后修改数组第一个元素。<code>printArray()</code>函数接受数组的指针并把数组全部打印出来。</p><p>参考答案：输出<code>10、2、3</code>三个值。延迟函数<code>printArray()</code>的参数在<code>defer</code>语句出现时就已经确定了，即数组的地址，由于延迟函数执行时机是在return语句之前，所以对数组的最终修改值会被打印出来。</p></div><h2 id="规则二-延迟函数执行按后进先出顺序执行-即先出现的defer最后执行" tabindex="-1">规则二：延迟函数执行按后进先出顺序执行，即先出现的<code>defer</code>最后执行 <a class="header-anchor" href="#规则二-延迟函数执行按后进先出顺序执行-即先出现的defer最后执行" aria-label="Permalink to &quot;规则二：延迟函数执行按后进先出顺序执行，即先出现的\`defer\`最后执行&quot;">​</a></h2><p>这个规则很好理解，定义<code>defer</code>类似于入栈操作，执行<code>defer</code>类似于出栈操作。</p><p>设计<code>defer</code>的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请<code>A</code>资源，再跟据<code>A</code>资源申请<code>B</code>资源，跟据<code>B</code>资源申请<code>C</code>资源，即申请顺序是:<code>A—&gt;B—&gt;C</code>，释放时往往又要反向进行。这就是<code>defer</code>设计成FIFO的原因。</p><p>每申请到一个用完需要释放的资源时，立即定义一个<code>defer</code>来释放资源是个很好的习惯。</p><h2 id="规则三-延迟函数可能操作主函数的具名返回值" tabindex="-1">规则三：延迟函数可能操作主函数的具名返回值 <a class="header-anchor" href="#规则三-延迟函数可能操作主函数的具名返回值" aria-label="Permalink to &quot;规则三：延迟函数可能操作主函数的具名返回值&quot;">​</a></h2><p>定义<code>defer</code>的函数，即主函数可能有返回值，返回值有没有名字没有关系，<code>defer</code>所作用的函数，即延迟函数可能会影响到返回值。</p><p>若要理解延迟函数是如何影响主函数返回值的，只要明白函数是如何返回的就足够了。</p>`,19),t=[p];function l(h,k,d,r,c,o){return a(),i("div",null,t)}const y=s(n,[["render",l]]);export{g as __pageData,y as default};
