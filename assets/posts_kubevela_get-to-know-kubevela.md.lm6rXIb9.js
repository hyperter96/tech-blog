import{j as s,b as i,c as a,aa as e}from"./chunks/framework._Kr-eMMD.js";const g=JSON.parse('{"title":"Kubevela系列一：初识 KubeVela，基于 OAM 模型的应用交付平台","description":"","frontmatter":{"sidebar":false,"cover":"https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/kubevela-cover1-application.png","date":"2023-09-09T00:00:00.000Z","author":"意琦行","tag":["Kubevela","应用交付","kubernetes"],"sticky":1,"next":{"text":"Kubevela系列二：Application Controller 源码分析(上)","link":"/posts/kubevela/application-controller-source-code-analysis-1"},"head":[]},"headers":[],"relativePath":"posts/kubevela/get-to-know-kubevela.md","filePath":"posts/kubevela/get-to-know-kubevela.md","lastUpdated":1713531160000}'),l={name:"posts/kubevela/get-to-know-kubevela.md"},n=e(`<h1 id="kubevela系列一-初识-kubevela-基于-oam-模型的应用交付平台" tabindex="-1">Kubevela系列一：初识 KubeVela，基于 OAM 模型的应用交付平台 <a class="header-anchor" href="#kubevela系列一-初识-kubevela-基于-oam-模型的应用交付平台" aria-label="Permalink to &quot;Kubevela系列一：初识 KubeVela，基于 OAM 模型的应用交付平台&quot;">​</a></h1><p>本文主要介绍了 KubeVela 是什么，解决了什么问题，以及如何解决的。</p><h2 id="kubevela介绍" tabindex="-1">Kubevela介绍 <a class="header-anchor" href="#kubevela介绍" aria-label="Permalink to &quot;Kubevela介绍&quot;">​</a></h2><h3 id="kubevela是什么" tabindex="-1">Kubevela是什么 <a class="header-anchor" href="#kubevela是什么" aria-label="Permalink to &quot;Kubevela是什么&quot;">​</a></h3><div class="info custom-block"><p class="custom-block-title">以下是 KubeVela 官网的描述：</p><p>KubeVela 是一个现代化的软件交付平台，它可以让你的应用交付在当今流行的混合、多云环境中变得更加简单、高效、可靠。</p><p>KubeVela 是基础设施无关的、可编程的，但最重要的是： 它是完全以应用为中心的。它可以帮助你构建多样化的云原生应用，并交付到任意的云和基础设施！</p></div><p>一句话总结：<strong>KubeVela 是一个以应用为中心的软件交付平台。</strong></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>KubeVela 将应用抽象成了 <code>Application</code> 对象，这也是 KubeVela 中的核心对象，后续会介绍到。</p></div><h3 id="kubevela-解决了什么问题" tabindex="-1">KubeVela 解决了什么问题 <a class="header-anchor" href="#kubevela-解决了什么问题" aria-label="Permalink to &quot;KubeVela 解决了什么问题&quot;">​</a></h3><p><strong>现状</strong>：尽管 K8S 统一了底层基础架构（提到应用交付、部署，大部分都是指往 k8s 上部署），但是它并没有在混合的分布式部署环境之上提供<strong>应用层的软件交付模型和抽象</strong>。</p><p><strong>一般解决方案</strong>：k8s 很复杂，为了让应用开发者(不熟悉 k8s)能够快速交付（将应用部署到 k8s），一般会搭建 PaaS 平台对底层 k8s 能力进行抽象封装，屏蔽复杂度向上提供一个简单易用的平台。</p><p><strong>痛点</strong>：但随着应用交付需求的增长，用户的诉求就一定会超出 PaaS 系统的能力边界，同时，<strong>K8s 生态本身的能力池固然丰富，但是社区里却并没有一个可扩展的、方便快捷的方式，能够帮助平台团队把这些能力快速“组装”成面向最终用户的功能（Feature）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/limit-by-platform.png" alt="图片" loading="lazy"></p><p><strong>KubeVela 的价值</strong>：能够简化混合环境的应用交付过程，同时又足够灵活。</p><ul><li>KubeVela 本身是一个面向混合交付环境同时又高可扩展的<strong>应用交付引擎</strong>，满足平台构建者的扩展和自建需求； <ul><li>基于该引擎可以快速扩展新功能，将底层能力向上层暴露</li><li>因此也称之为 PaaS 内核</li></ul></li><li>同时又附加了一系列开箱即用的扩展组件，能够让开发者自助式的开发、交付云原生应用。 <ul><li>内置了一些常用的插件，开箱即用</li></ul></li></ul><h3 id="kubevela-是怎么解决的" tabindex="-1">KubeVela 是怎么解决的 <a class="header-anchor" href="#kubevela-是怎么解决的" aria-label="Permalink to &quot;KubeVela 是怎么解决的&quot;">​</a></h3><p>简单地说，KubeVela 通过执行以下操作减轻了构建此类平台的复杂度：</p><ul><li><strong>以应用为中心</strong>：KubeVela 强制采用一种应用程序概念作为其主要 API，并且 所有 KubeVela 的功能仅可满足应用程序的需求。这是通过采用开放应用程序模型作为 KubeVela 的核心API来实现的。 <ul><li>基于 OAM 模型的应用 <a href="https://github.com/oam-dev/spec" target="_blank" rel="noreferrer">GitHub - oam-dev/spec: Open Application Model (OAM)</a>.</li></ul></li><li><strong>本地扩展</strong>：KubeVela 中的应用程序由各种模块化组件组成。Kubernetes 生态系统的功能可以随时通过 Kubernetes CRD 注册机制作为新的工作负载类型或特征添加到 KubeVela 中。</li><li><strong>简单但可扩展的抽象机制</strong>：KubeVela 引入了一个模板引擎（支持 CUE ），用于从 Kubernetes 资源中提取面向用户的模式。KubeVela 提供了一组内置的抽象作为起点，平台构建者可以随时自由地对其进行修改。抽象更改将在运行时生效，无需重新编译或重新部署 KubeVela。 和其他 PaaS 平台一样，都是对底层能力做封装，但是 KubeVela 采用 <strong>CUE 模版 + CRD 动态注册机制</strong>，提高了灵活性。</li></ul><h2 id="application" tabindex="-1">Application <a class="header-anchor" href="#application" aria-label="Permalink to &quot;Application&quot;">​</a></h2><p>KubeVela 中最核心的就是这个 <code>Application</code> 对象。</p><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p>KubeVela 围绕着云原生应用交付和管理场景展开，背后的应用交付模型是 <a href="https://kubevela.net/zh/docs/platform-engineers/oam/oam-model" target="_blank" rel="noreferrer">Open Application Model</a>，简称 OAM 。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>前面有提到：<strong>KubeVela 是一个以应用为中心的软件交付平台</strong>。因此应用是 KubeVela 中最核心的对象。</p></div><p>基于 OAM 模型，KubeVela将应用抽象成了一个 <code>Application</code> 对象，中文翻译可以叫做：应用部署计划。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>应用部署计划这个词可以说是非常贴切了。</p></div><p>因为一个 Application 对象中包含了以下 4 部分内容：</p><ul><li><strong>组件（Component）</strong>: 组件定义一个应用包含的待交付制品（二进制、Docker 镜像、Helm Chart…）或云服务。我们认为一个应用部署计划部署的是一个微服务单元，里面主要包含一个核心的用于频繁迭代的服务，以及一组服务所依赖的中间件集合（包含数据库、缓存、云服务等），一个应用中包含的组件数量应该控制在约 15 个以内。</li><li><strong>运维特征（Trait）</strong>: 运维特征是可以随时绑定给待部署组件的、模块化、可拔插的运维能力，比如：副本数调整（手动、自动）、数据持久化、 设置网关策略、自动设置 DNS 解析等。</li><li><strong>应用策略（Policy）</strong>: 应用策略负责定义指定应用交付过程中的策略，比如多集群部署的差异化配置、资源放置策略、安全组策略、防火墙规则、SLO 目标等。</li><li><strong>工作流步骤（WorkflowStep）</strong>: 工作流由多个步骤组成，允许用户自定义应用在某个环境的交付过程。典型的工作流步骤包括人工审核、数据传递、多集群发布、通知等。 **KubeVela 的核心是将应用部署所需的所有组件和各项运维动作，描述为一个统一的、与基础设施无关的“部署计划”，进而实现在混合环境中标准化和高效率的应用交付。**这使得最终用户无需关注底层细节，就可以使用丰富的扩展能力，并基于统一的概念自助式操作。</li></ul><p>就像下图这样，一个完整的 <code>Application</code> 对象需要包含这 4 部分内容：</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/kubevela-application-2.png" alt="图片" loading="lazy"></p><h3 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h3><p>而上面提到的这 4 个部分则是通过插件机制实现的， KubeVela 会像胶水一样基于 Kubernetes API 定义基础设施定义的抽象并将不同的能力组合起来。下图描述了概念间的关系：</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/kubevela-application-arch.png" alt="图片" loading="lazy"></p><p>也就是说 <code>Application</code> 对象主要是对各个模块进行组合，真正的功能实现由各个模块定义来提供。</p><p>同时 KubeVela 提供了 Application Controller 来维护 <code>Application</code> 对象状态，这个也是核心之一，挖个坑，后续写一篇文章分析一下具体工作流程。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>用户将一个 <code>Application</code> 对象交给 KubeVela 之后发生了什么。</p></div><h2 id="插件机制-模块定义" tabindex="-1">插件机制(模块定义) <a class="header-anchor" href="#插件机制-模块定义" aria-label="Permalink to &quot;插件机制(模块定义)&quot;">​</a></h2><p>KubeVela 的灵活性主要由<strong>插件机制</strong>提供，KubeVela 中称其为 <code>XDefinition</code>。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>存在不同叫法，一般插件、组件、模块定义都是一个东西。</p></div><p>前文提到 <code>Application</code> 对象中引用的几部分内容都是作为一个模块来实现的：</p><ul><li><code>Component</code></li><li><code>Trait</code></li><li><code>Policy</code></li><li><code>Workflow Step</code></li></ul><p>这部分讲述插件相关实现原理的：</p><ul><li>1）工作流程：插件机制如何为 KubeVela 提供灵活性</li><li>2）插件定义与注册：如何实现自己的插件</li><li>3）使用插件：终端用户怎么用我们定义的插件</li><li>4）UI 展示：新增插件后，如何快速实现 UI 展示</li></ul><h3 id="工作流程" tabindex="-1">工作流程 <a class="header-anchor" href="#工作流程" aria-label="Permalink to &quot;工作流程&quot;">​</a></h3><p>平台构建者定义插件，使用插件对底层能力进行封装抽象，终端用户直接使用封装好的插件，以屏蔽掉复杂的底层逻辑。</p><p>就像下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/kubevela-xdefinition-arch.png" alt="图片" loading="lazy"></p><p>在 这里 可以找到现有的插件列表。</p><p>在 KubeVela 中插件机制主要为了向终端用户屏蔽底层的复杂度，就像这样：用户只需要提供少量数据，经过插件处理后即可生成完整信息。</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/kubevela-xdefinition-usage.png" alt="图片" loading="lazy"></p><h3 id="定义插件" tabindex="-1">定义插件 <a class="header-anchor" href="#定义插件" aria-label="Permalink to &quot;定义插件&quot;">​</a></h3><p>插件在 KubeVela 中具体表现为一个叫做 <code>XDefinition</code> 的 CRD，因此定义插件主要是实现一个 <code>XDefinition</code> 的 CRD。</p><p>以下内容定义了一个 <code>component</code> 类型的，名为 <code>myraw</code> 的插件，借助该 <code>component</code> 用户可以将原生 k8s 对象作为 Application 的一部分。</p><p>核心为 <code>spec.schematic.cue</code> 部分</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">core.oam.dev/v1beta1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ComponentDefinition</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  annotations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    definition.oam.dev/description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">myRaw allow users to specify raw K8s object in properties.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      This definition is DEPRECATED, please use &#39;k8s-objects&#39; instead.</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    meta.helm.sh/release-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">kubevela</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    meta.helm.sh/release-namespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">vela-system</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">myraw</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  namespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">vela-system</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  schematic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    cue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        output: parameter</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        parameter: {}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  workload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">autodetects.core.oam.dev</span></span></code></pre></div><h3 id="注册插件" tabindex="-1">注册插件 <a class="header-anchor" href="#注册插件" aria-label="Permalink to &quot;注册插件&quot;">​</a></h3><p>注册插件实际上就是将上述 CR 对象 apply 到 k8s 集群，即可实现动态注册，不需要重新编译或者重启 KubeVela。</p><p>KubeVela 在解析 App 对象拿到具体组件后，根据组件名查询对应的 CR 对象拿到具体信息。</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/kubevela-xdefinition-register.png" alt="图片" loading="lazy"></p><p>查看</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> componentdefinitions.core.oam.dev</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vela-system</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> myraw</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NAME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    WORKLOAD-KIND</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   DESCRIPTION</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myraw</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                   myRaw</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> allow</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> users</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> specify</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> raw</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> K8s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> object</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> properties.</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> This</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> definition</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> DEPRECATED,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> please</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> use</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;k8s-objects&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> instead.</span></span></code></pre></div><h3 id="使用插件" tabindex="-1">使用插件 <a class="header-anchor" href="#使用插件" aria-label="Permalink to &quot;使用插件&quot;">​</a></h3><p>插件注册好之后，平台用户就可以使用该插件了，具体表现为可以在 <code>Application</code> 里引用该插件,就像这样：</p><p><code>properties</code> 里可以传任意值，比如这里直接定义了一个 <code>deploy</code> 对象</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">core.oam.dev/v1beta1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Application</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">vela-app</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  components</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">demo</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">myraw</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">apps/v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Deployment</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          labels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx-deployment</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          replicas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            matchLabels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">              app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">              labels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">                app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">              containers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx:latest</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">                  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">                  ports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">containerPort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span></code></pre></div><p>查看</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@tmp-1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# vela ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">APP</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         COMPONENT</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        TYPE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         TRAITS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        PHASE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          HEALTHY</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        STATUS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            CREATED-TIME</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vela-app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    demo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">             myraw</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                      running</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        healthy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                          2023-08-21</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 17:33:17</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +0800</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CST</span></span></code></pre></div><h3 id="ui展示" tabindex="-1">UI展示 <a class="header-anchor" href="#ui展示" aria-label="Permalink to &quot;UI展示&quot;">​</a></h3><p><a href="http://kubevela.net/zh/docs/platform-engineers/openapi-v3-json-schema" target="_blank" rel="noreferrer">Definition 生成 OpenAPI 描述 | KubeVela</a></p><p><a href="http://kubevela.net/zh/docs/reference/ui-schema" target="_blank" rel="noreferrer">UI 扩展 | KubeVela</a></p><p>在定义 <code>XDefinition</code> 之后 KubeVela 会自动根据内容生成 <code>json schema</code>，UI 界面则会自动根据该 Schema 内容进行展示。</p><p>如果自动生成的不够完美，还可以进行自定义。</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/kubevela-xdefinition-ui.png" alt="图片" loading="lazy"></p><p>至此，我们的插件定义的算是完成了，可以看到前后端都是可以动态扩展的，不需要重新编译以及重启任何服务。</p><h3 id="demo" tabindex="-1">Demo <a class="header-anchor" href="#demo" aria-label="Permalink to &quot;Demo&quot;">​</a></h3><p>这里以官方提供的 Demo 为例，演示一下如何借助 KubeVela 插件机制，快速将社区能力接入平台。</p><p>需求：实现一个 helm 应用部署能力。</p><p>容易想到的方案：基于 helm cli / sdk 封装一个应用，对外提供该能力。</p><p>KubeVela 中怎么实现：</p><p>因为社区中已经有了类似功能，比如 FluxCD 或者 ArgoCD 都可以实现 helm 应用的部署，那么我们只需要选其中一个封装成组件注册到 KubeVela 即可。</p><p>具体如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/kubevela-xdefinition-demo.png" alt="图片" loading="lazy"></p><p>因此，KubeVela 的玩法就是借助插件机制将社区能力快速接入到平台。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本文主要对 KubeVela 做了一个简要说明，核心部分为基于 OAM 模型的 <code>Application</code> 对象抽象，以及基于 <code>CUE 模板引擎 + CRD</code> 注册模式的插件系统(模块定义)。</p><ul><li><strong>KubeVela 是什么</strong>：KubeVela 是一个以应用为中心的软件交付平台。</li><li><strong>KubeVela 解决的问题</strong>：云原生社区能力&quot;无限&quot;,但是传统 PaaS 无法快速将这些能力接入进来。</li><li><strong>KubeVela 提供的解决方案</strong>：提供灵活的插件机制(模块定义)，以快速接入社区能力。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/limit-by-platform.png" alt="图片" loading="lazy"></p><p>如何实现的：</p><ul><li><strong>动态注册</strong>：KubeVela 中的应用程序由各种模块化组件组成。Kubernetes 生态系统的功能可以随时通过 Kubernetes CRD 注册机制作为新的工作负载类型或特征添加到 KubeVela 中。</li><li><strong>简单但可扩展的抽象机制</strong>：KubeVela 引入了一个模板引擎（支持 CUE ），用于从 Kubernetes 资源中提取面向用户的模式。KubeVela 提供了一组内置的抽象作为起点，平台构建者可以随时自由地对其进行修改。抽象更改将在运行时生效，无需重新编译或重新部署 KubeVela。</li><li><strong>自动生成 UI</strong>：自动根据模块内容生成 <code>json schema</code>，UI 界面则会自动根据该 Schema 内容进行展示。 和其他平台一样，都是对底层能力做封装，但是 KubeVela 采用 <code>CUE 模版 + CRD</code> 动态注册机制 + 自动生成 <code>UI Schema</code>，提高了灵活性。</li></ul>`,87),t=[n];function p(h,k,r,o,d,c){return i(),a("div",null,t)}const y=s(l,[["render",p]]);export{g as __pageData,y as default};
