import{_ as e,c as d,o as t,a7 as o}from"./chunks/framework.B28k8k1F.js";const m=JSON.parse('{"title":"MySQL知识系列二：MySQL索引","description":"","frontmatter":{"sidebar":false,"cover":"https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/mysql-cover.jpg","date":"2024-05-05T00:00:00.000Z","sticky":1,"tags":["kubernetes","MySQL"],"prev":{"text":"MySQL知识系列一：MySQL架构图","link":"/posts/mysql/mysql-infra"},"head":[]},"headers":[],"relativePath":"posts/mysql/mysql-index.md","filePath":"posts/mysql/mysql-index.md","lastUpdated":1739924119000}'),s={name:"posts/mysql/mysql-index.md"},c=o('<h1 id="mysql知识系列二-mysql索引" tabindex="-1">MySQL知识系列二：MySQL索引 <a class="header-anchor" href="#mysql知识系列二-mysql索引" aria-label="Permalink to &quot;MySQL知识系列二：MySQL索引&quot;">​</a></h1><p>存储引擎与底层实现的数据结构</p><p>数据结构 - 索引怎么选择合适的数据结构？中分析过能作为索引的数据结构主要有散列表（Hash表）、红黑树、跳表、B+树（B树）以及有序数组,并且分析了它们适合场景。Mysql的索引与存储引擎相关，但是Mysql内常用的存储引擎有InnoDB、MyiSAM、Memory，在Mysql5.5版本后，InnoDB已经作为默认的存储引擎，并且很多互联网公司基本都要求只能使用InnoDB存储引擎。Memory作为临时表的默认存储引擎，所以研究的重点基本就是InnodDB和Memory引擎，也就是基本关注B+树和散列表的数据结构索引。他们底层支持的数据结构如下图：</p><table tabindex="0"><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Hash索引</td><td></td><td></td><td>√</td></tr><tr><td>R-Tree索引</td><td>√</td><td></td><td></td></tr><tr><td>Full-text索引</td><td>√</td><td></td><td></td></tr></tbody></table><p>InnoDB存储引擎本身只支持B+树，之前分析过B+树比较适合磁盘存储。B+树是多路平衡搜索树，最佳实践N值为1200左右，树高为4时就可存储 1200的3次方，此时已经存储了17亿数据了。由于第一层数据总是在内存中，那么相当于17亿数据，最多查询磁盘3次，如果第二层刚好也在内存中，那么对多查询2次磁盘。也就是说InnoDB的最底层数据结构是B+树，B+树可能存储在内存中可能存储在磁盘中，存储的单元是数据页（操作系统数据缓存页），即数据缓存页是内存和磁盘的链接点。磁盘 -&gt; 数据页 -&gt; 内存</p><p>而查询数据所在的行到达在内存中还是在磁盘中，由服务器所在的 InnoDB缓存页大小决定，Buffer Pool由 <code>my.cnf</code>配置中的参数控制：</p><ul><li><code>innodb_buffer_pool_size</code>：引擎的缓存池大小，一般为物理内存的 <code>60% - 80%</code>；</li><li><code>innodb_buffer_pool_instances</code>：IBP（InnoDB Buffer Pool）的个数，Linux系统，如果 <code>innodb_buffer_pool_size</code> 大小超过 <code>1GB</code>，<code>innodb_buffer_pool_instances</code> 值就默认为 8；否则，默认为 1；</li></ul><p>缓存的大小有限，那么只能将数据命中率最高的放入缓存中，Mysql使用的LRU缓存淘汰算法。LRU可以理解成一个链表，链表的节点就是数据缓存页，刚被访问过的放到链表一头，最老被访问过的放到一头，当有新的数据缓存页被访问加入时，从最老的一头淘汰。但是链表本身删除节点的时间复杂度是<code>O(1)</code>,但是访问时间复杂度是<code>O(N)</code>,性能很低。怎么才能提高访问性能呢？ 一般会使用散列表进行访问，即整个LRU由散列表+双向链表组成，类似于Java中的<code>LinkedHashMap</code>的数据结构。</p><p>由于磁盘局部性原理，访问数据页时有预读数据页的功能，即我们从磁盘中获取到了多余的数据页，加入LRU的话就是浪费存储空间。还有我们可能会（处理报表等sql）对一个历史数据表进行整表分页全表查询一遍，那么也会对LRU照成冲击，可能需要很长的时间才能让缓存命中率恢复。针对预读数据页和冷数据扫描的情况，Mysql对LRU进行了改造，将LRU链分成 <code>5/8</code>的<code>young</code>区和 <code>3/8</code>的<code>old</code>区。当数据需要淘汰时直接从<code>old</code>区的末尾开始，而当新访问数据页时先判断在缓存中是否存在，如果不存在则直接将数据添加到<code>old</code>区，否则当满足下面配置时才会真正移动到<code>young</code>区域：<code>innodb_old_blocks_time：mysql</code>缓存页使用的LRU，<code>old</code>区升级为<code>young</code>区的时间判断。默认值<code>1000</code>，单位毫秒；</p><p><img src="https://cdn.jsdelivr.net/gh/hyperter96/tech-blog/docs/assets/images/linked-hash-map.png" alt="" loading="lazy"></p>',10),n=[c];function a(l,r,i,y,p,_){return t(),d("div",{"data-pagefind-body":!0},n)}const f=e(s,[["render",a]]);export{m as __pageData,f as default};
